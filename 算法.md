[toc]

## 常见的时间复杂度

~~~markdown
# 排名从好到差
	O(1)
	O(logN)
	O(N)
	O(N*logN)
	O(N^2) O(N^3) ... O(N^K)
	O(2^N) O(3^N) ... O(K^N)
	O(N!)
~~~

## Java包装类按值传递和按引用传递

~~~java
int a = 10000;
int b = 10000;
System.out.println(a == b); //true

Integer c = 10000;
Integer d = 10000;
System.out.println(c == d); //false

Integer e = 128;
Integer f = 128;
System.out.println(e == f); //false

Integer g = 127;
Integer h = 127;
System.out.println(g == h); //true
~~~

~~~markdown
# 当包装类整型的值在 -128 ~ 127 时，是按照『值传递』，其他情况是按照『引用传递的』
# 但是无论如何，在HashMap中是按照值传递的
~~~

## Java中的求中值

~~~markdown
# 求中值的几种写法
	mid = （L + R）/ 2
# 如果 L=10亿    R=10亿
	那么 L+R 就已经溢出了。
# 此时我们写为尽量不溢出的形式：L加上距离的一半
	mid = L + （R - L）/ 2;
# 为了提高运算效率，我们可以改为『位运算』
	mid = L + ((R - L) >> 1)
~~~



## 串的相关算法

![image-20210124092235405](https://i.loli.net/2021/01/24/d7BqKeIJ6mCoyh9.png)

### 串匹配算法



## 贪心算法

~~~markdown
# 是一种局部最功利的标准，总是做出在当前看来最好的选择
# 在计算机科学领域：贪心算法必须证明局部最功利的标准可以得到全局最优解
# 贪心算法，没有统一的解法，每次证明都是不同的数学方法，我们可以通过对数器来证明贪心策略的对错
~~~

## 暴力递归

~~~markdown
# 暴力递归就是尝试
1. 把问题转化为规模小的同类问题的子问题【分治】
2. 有明确的不需要继续进行递归的条件（base case）---》【终止条件】
3. 有当得到了子问题的结果之后的决策过程【回溯完做决策】
4. 不记录每一个子问题的解【暴力】===【如果记录了就是动态规划】


# 分治
	将大问题转化为规模小的同类子问题，这个过程就叫分治
# 回溯
	将大问题转化为规模小的同类子问题，子问题返回有用的信息，这就是回溯
~~~



### 

